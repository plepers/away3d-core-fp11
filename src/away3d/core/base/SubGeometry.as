package away3d.core.base
{
	import away3d.bounds.BoundingBox;
	import flash.profiler.Telemetry;
	import away3d.arcane;
	import away3d.core.managers.Stage3DProxy;
	import flash.display3D.Context3D;

	import flash.display3D.IndexBuffer3D;
	import flash.display3D.VertexBuffer3D;
	import flash.geom.Matrix3D;
	import flash.geom.Vector3D;

	use namespace arcane;

	/**
	 * The SubGeometry class is a collections of geometric data that describes a triangle mesh. It is owned by a
	 * Geometry instance, and wrapped by a SubMesh in the scene graph.
	 * Several SubGeometries are grouped so they can be rendered with different materials, but still represent a single
	 * object.
	 *
	 * @see away3d.core.base.Geometry
	 * @see away3d.core.base.SubMesh
	 */
	public class SubGeometry
	{
		protected var _parentGeometry : Geometry;

		// raw data:
//		protected var _customData : Vector.<Number>;
//		protected var _vertices : Vector.<Number>;
//		protected var _colors : Vector.<Number>;
//		protected var _uvs : Vector.<Number>;
//		protected var _secondaryUvs : Vector.<Number>;
//		protected var _vertexNormals : Vector.<Number>;
//		protected var _vertexTangents : Vector.<Number>;
//		protected var _indices : Vector.<uint>;
//		protected var _faceNormalsData : Vector.<Number>;
//		protected var _faceWeights : Vector.<Number>;
//		protected var _faceTangents : Vector.<Number>;

		// buffers:
		protected var _vertexBuffer : Vector.<VertexBuffer3D> = new Vector.<VertexBuffer3D>(8);
		protected var _colorBuffer : Vector.<VertexBuffer3D> = new Vector.<VertexBuffer3D>(8);
		protected var _uvBuffer : Vector.<VertexBuffer3D> = new Vector.<VertexBuffer3D>(8);
		protected var _secondaryUvBuffer : Vector.<VertexBuffer3D> = new Vector.<VertexBuffer3D>(8);
		protected var _vertexNormalBuffer : Vector.<VertexBuffer3D> = new Vector.<VertexBuffer3D>(8);
		protected var _vertexTangentBuffer : Vector.<VertexBuffer3D> = new Vector.<VertexBuffer3D>(8);
		protected var _customBuffer : Vector.<VertexBuffer3D>;
		protected var _indexBuffer : Vector.<IndexBuffer3D> = new Vector.<IndexBuffer3D>(8);

		protected var _autoGenerateUVs : Boolean = false;
		protected var _autoDeriveVertexNormals : Boolean = true;
		protected var _autoDeriveVertexTangents : Boolean = true;
		protected var _useFaceWeights : Boolean = false;

		// raw data dirty flags:
		protected var _uvsDirty : Boolean = true;
		protected var _faceNormalsDirty : Boolean = true;
		protected var _faceTangentsDirty : Boolean = true;
		protected var _vertexNormalsDirty : Boolean = true;
		protected var _vertexTangentsDirty : Boolean = true;
		protected var _vertexColorsDirty : Boolean = true;

		// buffer dirty flags, per context:
		protected var _vertexBufferContext : Vector.<Context3D> = new Vector.<Context3D>(8);
		protected var _colorBufferContext : Vector.<Context3D> = new Vector.<Context3D>(8);
		protected var _uvBufferContext : Vector.<Context3D> = new Vector.<Context3D>(8);
		protected var _secondaryUvBufferContext : Vector.<Context3D> = new Vector.<Context3D>(8);
		protected var _indexBufferContext : Vector.<Context3D> = new Vector.<Context3D>(8);
		protected var _vertexNormalBufferContext : Vector.<Context3D> = new Vector.<Context3D>(8);
		protected var _vertexTangentBufferContext : Vector.<Context3D> = new Vector.<Context3D>(8);
		protected var _customBufferContext : Vector.<Context3D>;

		protected var _numVertices : uint;
		protected var _numIndices : uint;
		protected var _numTriangles : uint;
		protected var _uvScaleV : Number = 1;
		protected var _customElementsPerVertex : int;


		/**
		 * Creates a new SubGeometry object.
		 */
		public function SubGeometry()
		{
		}

		/**
		 * The total amount of vertices in the SubGeometry.
		 */
		public function get numVertices() : uint
		{
			return _numVertices;
		}

		/**
		 * The total amount of triangles in the SubGeometry.
		 */
		public function get numTriangles() : uint
		{
			return _numTriangles;
		}
		
		
		/**
		 * Defines whether a UV buffer should be automatically generated to contain dummy UV coordinates.
		 * Set to true if a geometry lacks UV data but uses a material that requires it, or leave as false
		 * in cases where UV data is explicitly defined or the material does not require UV data.
		*/
		public function get autoGenerateDummyUVs() : Boolean
		{
			return _autoGenerateUVs;
		}
		
		public function set autoGenerateDummyUVs(value : Boolean) : void
		{
			_autoGenerateUVs = value;
			_uvsDirty = value;
		}
		

		/**
		 * True if the vertex normals should be derived from the geometry, false if the vertex normals are set
		 * explicitly.
		 */
		public function get autoDeriveVertexNormals() : Boolean
		{
			return _autoDeriveVertexNormals;
		}

		public function set autoDeriveVertexNormals(value : Boolean) : void
		{
			_autoDeriveVertexNormals = value;

			_vertexNormalsDirty = value;
		}

		/**
		 * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.
		 */
		public function get useFaceWeights() : Boolean
		{
			return _useFaceWeights;
		}

		public function set useFaceWeights(value : Boolean) : void
		{
			_useFaceWeights = value;
			if (_autoDeriveVertexNormals) _vertexNormalsDirty = true;
			if (_autoDeriveVertexTangents) _vertexTangentsDirty = true;
			_faceNormalsDirty = true;
		}

		/**
		 * True if the vertex tangents should be derived from the geometry, false if the vertex normals are set
		 * explicitly.
		 */
		public function get autoDeriveVertexTangents() : Boolean
		{
			return _autoDeriveVertexTangents;
		}

		public function set autoDeriveVertexTangents(value : Boolean) : void
		{
			_autoDeriveVertexTangents = value;

			_vertexTangentsDirty = value;
		}

		public function initCustomBuffer(numVertices : int, elementsPerVertex : int) : void
		{
			_numVertices = numVertices;
			_customElementsPerVertex = elementsPerVertex;
			_customBuffer = new Vector.<VertexBuffer3D>(8);
			_customBufferContext = new Vector.<Context3D>(8);
		}

		/**
		 * A buffer allowing you any sort of data. Needs to be initialized by calling initCustomBuffer
		 * @param stage3DProxy
		 * @return
		 */
		public function getCustomBuffer(stage3DProxy : Stage3DProxy) : VertexBuffer3D
		{
			var contextIndex : int = stage3DProxy._stage3DIndex;
			var context : Context3D = stage3DProxy._context3D;
			if (_customBufferContext[contextIndex] != context || !_customBuffer[contextIndex]) {
				_customBuffer[contextIndex] = context.createVertexBuffer(_numVertices, _customElementsPerVertex);
				_uploadCustom( _customBuffer[contextIndex] );
				_customBufferContext[contextIndex] = context;
 			}

			return _customBuffer[contextIndex];
		}

		/**
		 * Retrieves the VertexBuffer3D object that contains vertex positions.
		 * @param context The Context3D for which we request the buffer
		 * @return The VertexBuffer3D object that contains vertex positions.
		 */
		public function getVertexBuffer(stage3DProxy : Stage3DProxy) : VertexBuffer3D
		{
			var contextIndex : int = stage3DProxy._stage3DIndex;
			var context : Context3D = stage3DProxy._context3D;
			if (_vertexBufferContext[contextIndex] != context || !_vertexBuffer[contextIndex]) {
				_vertexBuffer[contextIndex] = context.createVertexBuffer(_numVertices, 3);
				_uploadVertex( _vertexBuffer[contextIndex] );
				_vertexBufferContext[contextIndex] = context;
 			}

			return _vertexBuffer[contextIndex];
		}


		public function getColorBuffer(stage3DProxy : Stage3DProxy) : VertexBuffer3D
		{
			var contextIndex : int = stage3DProxy._stage3DIndex;
			var context : Context3D = stage3DProxy._context3D;
			if (_colorBufferContext[contextIndex] != context || !_colorBuffer[contextIndex]) {
				_colorBuffer[contextIndex] = context.createVertexBuffer(_numVertices, 3);
				_uploadColor( _colorBuffer[contextIndex] );
				_colorBufferContext[contextIndex] = context;
 			}

			return _colorBuffer[contextIndex];
		}

		/**
		 * Retrieves the VertexBuffer3D object that contains texture coordinates.
		 * @param context The Context3D for which we request the buffer
		 * @return The VertexBuffer3D object that contains texture coordinates.
		 */
		public function getUVBuffer(stage3DProxy : Stage3DProxy) : VertexBuffer3D
		{
			var contextIndex : int = stage3DProxy._stage3DIndex;
			var context : Context3D = stage3DProxy._context3D;

			if (_autoGenerateUVs && _uvsDirty)
				updateDummyUVs();

			if (_uvBufferContext[contextIndex] != context || !_uvBuffer[contextIndex]) {
				_uvBuffer[contextIndex] = context.createVertexBuffer(_numVertices, 2);
				_uploadUv( _uvBuffer[contextIndex] );
				_uvBufferContext[contextIndex] = context;
 			}

			return _uvBuffer[contextIndex];
		}


		public function getSecondaryUVBuffer(stage3DProxy : Stage3DProxy) : VertexBuffer3D
		{
			var contextIndex : int = stage3DProxy._stage3DIndex;
			var context : Context3D = stage3DProxy._context3D;

			if (_secondaryUvBufferContext[contextIndex] != context || !_secondaryUvBuffer[contextIndex]) {
				_secondaryUvBuffer[contextIndex] = context.createVertexBuffer(_numVertices, 2);
				_uploadSecondaryUv( _secondaryUvBuffer[contextIndex] );
				_secondaryUvBufferContext[contextIndex] = context;
 			}

			return _secondaryUvBuffer[contextIndex];
		}

		/**
		 * Retrieves the VertexBuffer3D object that contains vertex normals.
		 * @param context The Context3D for which we request the buffer
		 * @return The VertexBuffer3D object that contains vertex normals.
		 */
		public function getVertexNormalBuffer(stage3DProxy : Stage3DProxy) : VertexBuffer3D
		{
			var contextIndex : int = stage3DProxy._stage3DIndex;
			var context : Context3D = stage3DProxy._context3D;

			if (_autoDeriveVertexNormals && _vertexNormalsDirty)
				updateVertexNormals();

			if (_vertexNormalBufferContext[contextIndex] != context || !_vertexNormalBuffer[contextIndex]) {
				_vertexNormalBuffer[contextIndex] = context.createVertexBuffer(_numVertices, 3);
				_uploadVertexNormal( _vertexNormalBuffer[contextIndex] );
				_vertexNormalBufferContext[contextIndex] = context;
 			}

			return _vertexNormalBuffer[contextIndex];
		}

		/**
		 * Retrieves the VertexBuffer3D object that contains vertex tangents.
		 * @param context The Context3D for which we request the buffer
		 * @return The VertexBuffer3D object that contains vertex tangents.
		 */
		public function getVertexTangentBuffer(stage3DProxy : Stage3DProxy) : VertexBuffer3D
		{
			var contextIndex : int = stage3DProxy._stage3DIndex;
			var context : Context3D = stage3DProxy._context3D;

			if (_vertexTangentsDirty)
				updateVertexTangents();

			if (_vertexTangentBufferContext[contextIndex] != context || !_vertexTangentBuffer[contextIndex]) {
				_vertexTangentBuffer[contextIndex] = context.createVertexBuffer(_numVertices, 3);
				_uploadVertexTangent( _vertexTangentBuffer[contextIndex] );
				_vertexTangentBufferContext[contextIndex] = context;
 			}
			return _vertexTangentBuffer[contextIndex];
		}

		/**
		 * Retrieves the VertexBuffer3D object that contains triangle indices.
		 * @param context The Context3D for which we request the buffer
		 * @return The VertexBuffer3D object that contains triangle indices.
		 */
		public function getIndexBuffer(stage3DProxy : Stage3DProxy) : IndexBuffer3D
		{
			var contextIndex : int = stage3DProxy._stage3DIndex;
			var context : Context3D = stage3DProxy._context3D;

			if (_indexBufferContext[contextIndex] != context || !_indexBuffer[contextIndex]) {
				_indexBuffer[contextIndex] = context.createIndexBuffer(_numIndices);
				_uploadIndex( _indexBuffer[contextIndex] );
				_indexBufferContext[contextIndex] = context;
 			}

			return _indexBuffer[contextIndex];
		}



		/**
		 * Clones the current object
		 * @return An exact duplicate of the current object.
		 */
		public function clone() : SubGeometry { return null; }
		
		public function applyTransformation(transform:Matrix3D):void {}

		/**
		 * Scales the geometry.
		 * @param scale The amount by which to scale.
		 */
		public function scale(scale : Number):void {}

		/**
		 * Scales the uv coordinates
		 * @param scaleU The amount by which to scale on the u axis. Default is 1;
		 * @param scaleV The amount by which to scale on the v axis. Default is 1;
		 */
		protected var _scaleU : Number = 1;
		protected var _scaleV : Number = 1;
		
		public function get scaleU():Number
		{
			return _scaleU;
		}
		
		public function get scaleV():Number
		{
			return _scaleV;
		}
		 
		public function scaleUV(scaleU : Number = 1, scaleV : Number = 1):void{}

		/**
		 * Clears all resources used by the SubGeometry object.
		 */
		public function dispose() : void
		{
			
			disposeAllVertexBuffers();
			disposeIndexBuffers(_indexBuffer);
			_customBuffer = null;
			_vertexBuffer = null;
			_vertexNormalBuffer = null;
			_uvBuffer = null;
			_secondaryUvBuffer = null;
			_vertexTangentBuffer = null;
			_indexBuffer = null;
			_vertexBufferContext = null;
			_uvBufferContext = null;
			_secondaryUvBufferContext = null;
			_indexBufferContext = null;
			_vertexNormalBufferContext = null;
			_vertexTangentBufferContext = null;
			_customBufferContext = null;
		}

		protected function disposeAllVertexBuffers() : void
		{
			
			disposeVertexBuffers(_vertexBuffer);
			disposeVertexBuffers(_vertexNormalBuffer);
			disposeVertexBuffers(_uvBuffer);
			disposeVertexBuffers(_secondaryUvBuffer);
			disposeVertexBuffers(_vertexTangentBuffer);
			if (_customBuffer) disposeVertexBuffers(_customBuffer);
		}


		/**
		 * The raw data of the face normals, in the same order as the faces are listed in the index list.
		 *
		 * @private
		 */
		arcane function get faceNormalsData() : Vector.<Number>
		{
			return null;
		}

		/**
		 * The Geometry object that 'owns' this SubGeometry object.
		 *
		 * @private
		 */
		arcane function get parentGeometry() : Geometry
		{
			return _parentGeometry;
		}

		arcane function set parentGeometry(value : Geometry) : void
		{
			_parentGeometry = value;
		}
		
		
		
		protected function _uploadCustom(customBuffer : VertexBuffer3D) : void {}                // abstract
		protected function _uploadVertex(vertexBuffer : VertexBuffer3D) : void {}                // abstract
		protected function _uploadColor(colorBuffer : VertexBuffer3D) : void {}                  // abstract
		protected function _uploadUv(uvBuffer : VertexBuffer3D) : void {}                        // abstract
		protected function _uploadSecondaryUv(secondaryUvBuffer : VertexBuffer3D) : void {}      // abstract
		protected function _uploadVertexNormal(vertexNormalBuffer : VertexBuffer3D) : void {}    // abstract
		protected function _uploadVertexTangent(vertexTangentBuffer : VertexBuffer3D) : void {}  // abstract
		protected function _uploadIndex(indexBuffer : IndexBuffer3D) : void {}                   // abstract
		
		/**
		 * Invalidates all buffers in a vector, causing them the update when they are first requested.
		 * @param buffers The vector of buffers to invalidate.
		 */
		protected function invalidateBuffers(buffers : Vector.<Context3D>) : void
		{
			for (var i : int = 0; i < 8; ++i)
				buffers[i] = null;
		}

		/**
		 * Disposes all buffers in a given vector.
		 * @param buffers The vector of buffers to dispose.
		 */
		protected function disposeVertexBuffers(buffers : Vector.<VertexBuffer3D>) : void
		{
			
			for (var i : int = 0; i < 8; ++i) {
				if (buffers[i]) {
					buffers[i].dispose();
					buffers[i] = null;
				}
			}
		}

		/**
		 * Disposes all buffers in a given vector.
		 * @param buffers The vector of buffers to dispose.
		 */
		protected function disposeIndexBuffers(buffers : Vector.<IndexBuffer3D>) : void
		{
			for (var i : int = 0; i < 8; ++i) {
				if (buffers[i]) {
					buffers[i].dispose();
					buffers[i] = null;
				}
			}
		}

		
		
		
		protected function updateVertexNormals() : void {}
		
		protected function updateDummyUVs() : void {}

		/**
		 * Updates the vertex tangents based on the geometry.
		 */
		protected function updateVertexTangents() : void {}

		/**
		 * Updates the normals for each face.
		 */
		protected function updateFaceNormals() : void {}

		/**
		 * Updates the tangents for each face.
		 */
		protected function updateFaceTangents() : void {}

		protected function disposeForStage3D(stage3DProxy : Stage3DProxy) : void
		{
			var index : int = stage3DProxy._stage3DIndex;
			if (_vertexBuffer[index]) {
				_vertexBuffer[index].dispose();
				_vertexBuffer[index] = null;
			}
			if (_uvBuffer[index]) {
				_uvBuffer[index].dispose();
				_uvBuffer[index] = null;
			}
			if (_secondaryUvBuffer[index]) {
				_secondaryUvBuffer[index].dispose();
				_secondaryUvBuffer[index] = null;
			}
			if (_vertexNormalBuffer[index]) {
				_vertexNormalBuffer[index].dispose();
				_vertexNormalBuffer[index] = null;
			}
			if (_vertexTangentBuffer[index]) {
				_vertexTangentBuffer[index].dispose();
				_vertexTangentBuffer[index] = null;
			}
			if (_indexBuffer[index]) {
				_indexBuffer[index].dispose();
				_indexBuffer[index] = null;
			}
		}
		
		public function contributeBounds( bb : BoundingBox ) : void {
			// abstract
		}

		public function get vertexBufferOffset() : int
		{
			return 0;
		}

		public function get colorBufferOffset() : int
		{
			return 0;
		}
		
		public function get normalBufferOffset() : int
		{
			return 0;
		}

		public function get tangentBufferOffset() : int
		{
			return 0;
		}

		public function get UVBufferOffset() : int
		{
			return 0;
		}

		public function get secondaryUVBufferOffset() : int
		{
			return 0;
		}
	}
}